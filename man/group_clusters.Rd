% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group_clusters.R
\name{group_clusters}
\alias{group_clusters}
\title{Partition Cocktail nodes (clusters) into k groups}
\usage{
group_clusters(
  x,
  phi_cut = 0.3,
  k_partition = 2L,
  method = c("kmeans", "hclust"),
  feature_scale = TRUE,
  kmeans_seed = NULL,
  dist_method = "manhattan",
  clust_method = "average",
  use_parallelDist = FALSE,
  use_fastcluster = FALSE
)
}
\arguments{
\item{x}{Cocktail object with \code{Cluster.height} and \code{Plot.cluster}.}

\item{phi_cut}{Numeric in (0,1). Keep \strong{all} nodes with height \eqn{\ge} \code{phi_cut}.}

\item{k_partition}{Positive integer, number of node groups to form.}

\item{method}{\code{"kmeans"} or \code{"hclust"}.}

\item{feature_scale}{Logical; if \code{TRUE} (default), standardize plot-columns.}

\item{kmeans_seed}{Optional integer seed for reproducible k-means.}

\item{dist_method}{Distance for \code{method="hclust"} (default \code{"manhattan"}).}

\item{clust_method}{Linkage for \code{method="hclust"} (default \code{"average"}).}

\item{use_parallelDist}{Logical; if \code{TRUE}, try \code{parallelDist::parDist()};
fallback to \code{stats::dist()}.}

\item{use_fastcluster}{Logical; if \code{TRUE}, try \code{fastcluster::hclust()};
fallback to \code{stats::hclust()}.}
}
\value{
A named character vector mapping node labels (e.g., \code{"c_123"}) to
partition labels (\code{"g1"}, \code{"g2"}, ...). The object has attributes:
\itemize{
\item \code{"clusters_for_assign"}: \strong{list of integer vectors},
one per group \code{g1..gK}, each containing the node IDs in that group.
\item \code{"details"}: list with method, \code{k_partition}, kept node IDs,
dedup info, and (for hclust) the \code{hclust} object and settings.
}
}
\description{
Partitions \strong{nodes of the Cocktail tree} (i.e., internal clusters) into
\code{k_partition} groups using either k-means or hierarchical clustering.

Steps:
\enumerate{
\item \strong{Select nodes:} keep \strong{all} nodes whose height \eqn{\phi} is
\code{>= phi_cut}. (No “topmost” filtering: ancestors and descendants
that pass the cut are all kept.)
\item \strong{Feature matrix (nodes × plots):} take \code{x$Plot.cluster} columns for
the kept nodes and transpose to get a binary matrix with \strong{rows = nodes},
\strong{columns = plots}.
\item \strong{Deduplicate identical nodes:} if two nodes have identical plot
memberships, drop duplicates \strong{keeping the rightmost node} (highest column
index in the original \code{Plot.cluster}).
\item \strong{(Optional) feature scaling:} standardize plot-columns when
\code{feature_scale = TRUE} so plots contribute comparably.
\item \strong{Partition nodes:}
\itemize{
\item \code{method = "kmeans"}: k-means on the node × plot matrix.
\item \code{method = "hclust"}: distances (default Manhattan) + linkage
(default UPGMA/"average") → cut into \code{k_partition} groups.
Group IDs are \strong{relabeled} in dendrogram left-to-right order for readability.
}
}
}
\details{
This function clusters \strong{nodes} (not plots). The returned grouping can be fed
directly to \code{assign_releves(clusters = ...)}: we return
\code{attr(result, "clusters_for_assign")} as a \strong{list of integer vectors},
where each list element corresponds to one partition group \code{g1, g2, ...},
and contains the \strong{node IDs} (integers) assigned to that group. If any nodes
were removed as duplicates (identical plot membership), we keep only the
rightmost occurrence.

Group labels are always \code{"g1"}, \code{"g2"}, ... regardless of method.
}
\seealso{
\code{\link{assign_releves}}
}
